1. 可以

13. a) 先从根通过取最小儿子，找到一条通往树叶的路径，经过 logN 次比较。再通过二分搜索在 logN 个元素中找到 hole 的位置，花费 O(LogLog N) 
b) 先从根通过取最小儿子，找到一条通往树叶的路径。经过 logN - loglogN 个元素后，比较 hole 应该在当前元素上还是下。如果在当前元素之下，继续寻找补完路径上的的 loglogN 个元素（共花费 logN），二分搜索 loglogN 个元素，花费 O(logloglogN)：共计 logN + logloglogN。

16. 递归，按二进制值位从高到低，0：左子树，1表示右子树

17. a) 负无穷做根，两个子堆分别为左右孩子，执行 deleteMin()
b) 负无穷做根，项较多的堆为左子堆，另一个为右子堆，执行 deleteMin()

21. 成立，数学归纳法可证
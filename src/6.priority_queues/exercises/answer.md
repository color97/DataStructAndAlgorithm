1. 可以

13. a) 先从根通过取最小儿子，找到一条通往树叶的路径，经过 logN 次比较。再通过二分搜索在 logN 个元素中找到 hole 的位置，花费 O(LogLog N) 

    b) 先从根通过取最小儿子，找到一条通往树叶的路径。经过 logN - loglogN 个元素后，比较 hole 应该在当前元素上还是下。
        
        - 如果在当前元素之下，继续寻找补完路径上的的 loglogN 个元素（共花费 logN），再二分搜索 loglogN 个元素，花费 O(logloglogN)：共计 logN + logloglogN。
        - 如果在当前元素之上，二分搜索 logN - loglogN 个元素，花费至多 loglogN 次比较，共计 logN
        - case 1 花费更高
    
    c) ?

    d) 对比构建储存路径信息的容器花费

16. 递归，按二进制值位从高到低，0：左子树，1表示右子树

17. a) 负无穷做根，两个子堆分别为左右孩子，执行 deleteMin()
b) 负无穷做根，项较多的堆为左子堆，另一个为右子堆，执行 deleteMin()

21. 成立，数学归纳法可证

25. (a) 标准的做法是把操作分解为几个部分。每当第一个元素再次在出队列的堆中出现
时便是一个新部分的开始。第一部分大致耗费 2 * 1 * (N / 2)个时间单元，因为有 N /
2 个对右路径（译者注：含根节点）上只有一个节点的树进行的合并操作。下一个
部分耗费 2 * 2 * (N / 4)个时间单元，因为大致有 N / 4 个对右路径上至多只有两个
节点的树进行的合并操作。第三部分耗费 2 * 3 * (N / 8)个时间单元，以此类推。它们
和收敛于 4N。

    (b) 这样产生的左式堆更“左”。

29. 可以。每部分由左式堆的最坏时间变为摊还时间，但他们的和就是最坏时间

33. This is established in Chapter 11